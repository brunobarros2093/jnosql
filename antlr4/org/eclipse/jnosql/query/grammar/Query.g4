grammar Query;

select: 'select' fields 'from' entity where? skip? limit? order? EOF;
delete: 'delete' deleteFields? 'from' entity where? EOF;
insert: 'insert' entity (conditions | json) ttl? EOF;
update: 'update' entity (conditions | json) EOF;
get: 'get' keys EOF;
del: 'del' keys EOF;
put: 'put' '{' key ',' value (',' ttl)?  '}' EOF;

fields: star | name (',' name)*;
deleteFields: name (',' name)*;
conditions: '(' changes ')';
star: '*';
skip: 'skip' INT;
limit: 'limit' INT;
order: 'order' 'by' orderName (orderName)*;
orderName: name | name asc | name desc;
where: 'where' condition (and condition| or condition)* ;
condition: eq | gt | gte | lt | lte | between | in | like;
eq: not? name '=' value;
gt: not? name '>' value;
gte: not? name '>=' value;
lt: not? name '<' value;
lte: not? name '<=' value;
between: not? name 'between' value 'and' value;
in: name not? 'in' '('value (',' value)* ')';
like: name not? 'like' value_string;
not: 'not';
asc: 'asc';
desc: 'desc';
and: 'and';
or: 'or';
ttl: INT unit;
unit: 'day' | 'hour' | 'minute' | 'second' | 'millisecond' | 'nanosecond';
changes: change (',' change)*;
change: name '=' value;
key: value;
keys: value (','value)*;
value: ( number | string | bool | array | function | parameter | json);
value_string: string | parameter;
name: ANY_NAME;
entity: ANY_NAME;
array: '{' element (',' element)* '}';
function: convert;
convert: 'convert(' element ',' name')';
element: number | string;
number: '-'? (NUMBER | INT);
string: STRING;
bool: BOOLEAN;
json: object_json | array_json;
object_json:  '{' pair_json (',' pair_json)* '}' | '{' '}';
pair_json:   STRING ':' value_json ;
value_json: STRING | BOOLEAN | number | object_json |  array_json | 'null';
array_json: '[' value_json (',' value_json)* ']'| '[' ']';
parameter: PARAMETER;
STRING :  '\'' ( ESC | ~('\\'|'\'') )* '\'' |'"' ( ESC | ~('\\'|'"') )* '"';
INT: [0-9]+;
NUMBER: INT [.]? INT?;
BOOLEAN: 'true' | 'false';
ANY_NAME: [a-zA-Z_.][a-zA-Z_.0-9-]*;
PARAMETER: '@' ANY_NAME;
WS: [ \t\r\n]+ -> skip ;
SL_COMMENT: '//' .*? '\n' -> skip;
fragment ESC :   '\\' (["\\/bfnrt] | UNICODE) ;
fragment UNICODE : 'u' HEX HEX HEX HEX ;
fragment HEX : [0-9a-fA-F] ;